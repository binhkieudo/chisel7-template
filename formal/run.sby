[options]
mode prove
depth 40
multiclock on

[tasks]
aiger_avy

[engines]
abc pdr

[script]
read -sv AsyncQueueSink_UInt64.sv
read -sv AsyncQueueSource_UInt64.sv
read -sv AsyncQueue.sv
read -sv CdcMem.sv
read -sv MemoryAdapterMsgSync.sv
read -sv sdp_hw.sv
read -sv SinkOutput_UInt64.sv
read -sv SourceInput_UInt64.sv
read -sv synopsys_sync.sv
read -sv formal_setup.sv
chformal -assume -early
prep -top MemoryAdapterMsgSync

[files]
${SRC_DIR}/AsyncQueueSink_UInt64.sv
${SRC_DIR}/AsyncQueueSource_UInt64.sv
${SRC_DIR}/AsyncQueue.sv
${SRC_DIR}/CdcMem.sv
${SRC_DIR}/MemoryAdapterMsgSync.sv
${SRC_DIR}/sdp_hw.sv
${SRC_DIR}/SinkOutput_UInt64.sv
${SRC_DIR}/SourceInput_UInt64.sv
${SRC_DIR}/synopsys_sync.sv

[file formal_setup.sv]
module formal_setup();
    (* gclk *) reg gclk;

    // blockClock: toggle every gclk posedge
    reg clk_block;
    initial clk_block = 1'b0;
    always @(posedge gclk)
        clk_block <= !clk_block;

    reg [3:0]block_rst_counter = 2;
    always @(posedge clk_block)
        if (block_rst_counter > 0)
            block_rst_counter <= block_rst_counter - 1'b1;
    wire block_rst = block_rst_counter > 0;

    // hubClock: toggle every other clk_block posedge (different domain)
    reg clk_hub;
    initial clk_hub = 1'b0;
    always @(posedge gclk)
        clk_hub <= !clk_hub;    

    reg [3:0]hub_rst_counter = 2;
    always @(posedge clk_hub)
        if (hub_rst_counter > 0)
            hub_rst_counter <= hub_rst_counter - 1'b1;
    wire hub_rst = hub_rst_counter > 0;

    always @(*) begin
        assume(MemoryAdapterMsgSync.io_blockClock == clk_block);
        assume(MemoryAdapterMsgSync.io_hubClock == clk_hub);
        assume(MemoryAdapterMsgSync.io_blockReset == block_rst);
        assume(MemoryAdapterMsgSync.io_hubReset == hub_rst);
    end
endmodule

bind MemoryAdapterMsgSync formal_setup formal_setup_inst (.*);
